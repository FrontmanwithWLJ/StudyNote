# Android 面试准备

#### 计算机基础（通信UDP\TCP\IP 三次握手、四次挥手）

 ##### UDP

User Datagarm Protocol  用户数据报协议，位于OSI模型中的运输层

特点：

- 无连接
- 不可靠
- 快速传输（首部开销小）

###### UDP报文段格式

![UDP首部字段](https://upload-images.jianshu.io/upload_images/2053709-4b2a2f4e00243758.png?imageMogr2/auto-orient/strip|imageView2/2/w/1180/format/webp)

其中分为两个部分：UDP伪首部、UDP首部

1. UDP伪首部：

共12字节：4字节源IP地址、4字节目的IP地址、填充0(占一个字节)、一个字节协议字段（UDP为17、TCP为16）、两个字节UDP长度（与下面的首部字段中的长度一致）

*注意* ：这些字段的不会向下传送也不会向上递交，是从IP分组的头部获取的。

2. UDP**首部字段**

（仅有8个字节即64个比特，首部开销较小也是它的优势之一）分为四个字段每个字段占2字节：

1. 前两个字段分别为**16位的源端口号和16位目的端口号**（计算机端口共65535个即2的16次方-1）

2. 后两个字段分别是长度、检验和，同样都是两个字节的长度

   - 长度：单位为**字节**，最大表示长度就为2^16 = 65535字节，那么数据报单次传输内容的长度限制是不是就是它呢？

   - 检验和：UDP通过检验和提供差错检测功能。将前面三个字段（源端口号、目的端接口号、长度）相加得到的值取反码即为检验和

###### UDP差错检测

已知检验和为源端口号、目的端接口号、长度三者相加得到的值取反码，那么三者相加的值再加上检验和 等于 一个所有位数都为1的二进制数。例如： 和为1001 0110，则检验和为：0110 1001

 1001 0110+0110 1001 = 1111 1111

则可以通过的最后结果中有没有0来判断数据是否出现差错。



##### TCP

Tranform Controller Protocol 传输控制协议，同样位于OSI模型中的运输层。

###### 特点

- 面向字节流
- 提供全双工通信
- 可靠的通信方式（无差错、不丢失、不重复）
- 面向连接的单播协议
- 在网络状况不佳的时候尽量降低系统由于重传带来的带宽开销
- 通信连接维护时面向通信的两个端口的，而不考虑中间网段和节点



###### TCP报文段格式

ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。

![三次握手，四次挥手](https://pic3.zhimg.com/80/v2-e8aaab48ff996e5cd8a5b39dc450bd6a_720w.jpg)

###### 三次握手

最明显的作用就是使得双方都明确对方的收、发功能正常，同时相比直接连接无须三次握手相比，极大程度上减少了服务器被恶意攻击多次连接导致服务器大量资源处于等待阶段，从而导致资源浪费。

*注*：报文段中存在一个序号Seq number 和一个确认序号Ack number，此外还有一个ACK字段位长度为1。只有当ACK为1时Ack number才有效

1. 第一次握手 

   客户端向服务器发送SYN报文，即SYN字段值为1

2. 第二次握手

   服务器接收到SYN报文说明客户端的发功能正常，接着向客户端发送SYNACk报文，即SYN、ACK字段值为1，且Ack number = Seq number+1 表明收到了上一个报文

3. 第三次握手

   客户端接收到SYNACK报文说明服务器的收发能力都正常，向服务器发送ACK报文，Ack number = 上一个Seq number+1 表明收到了上一个报文，使得服务器知道客户端的收发能力正常，即连接成功。

###### 四次挥手

![四次挥手](https://pic3.zhimg.com/80/v2-629f51f6f535ebd7683f944707b21d1e_720w.jpg)

1. 第一次挥手

   客户端发送FIN报文，并附带当前Seq number、Ack number 和ACK用于确认收到了上一个包。

2. 第二次挥手

   服务器接收到FIN报文，会将还没发送的数据发送，然后发送ACK报文，此时客户端不会再发送消息了即发功能已关闭，只是再等待服务器发送的关闭报文。

3. 第三次挥手

   服务器发送FIN报文，Ack number  = 客户端FIN报文序号Seq number + 1,ACK = 1。

4. 第四次挥手

   客户端接收到FIN报文，向服务器发送ACK报文，Ack number = 服务器FIN报文序号Seq number + 1 ，ACK = 1。

###### 为什么建立连接是三次握手而断开连接是四次挥手？

建立连接时需要判断双方的收发能力是否正常，而要完成这个操作最少需要发送三次报文，即三次握手；分析建立连接时发送的报文可以看到，三次握手发送的报文分别为 SYN 、SYN+ACK、ACK三个报文，即第二次握手时同时发送了SYN建立连接ACK确认报文，而断开连接报文分别是：FIN、ACK、FIN、ACk，很明显是中间的ACK和FIN报文分开发送了，它们不能合并的原因是服务器接收到客户端的FIN报文，说明客户端想要关闭连接了，即客户端不会再发送消息，但是依然能接收消息，此时服务器可以选择立即关闭连接也可以选择把没发送的报文发送过去再关闭连接，所以会将FIN和ACK报文分开等到服务器将要发送的报文发送完毕，再发送FIN报文通知客户端现在关闭连接。

###### 拥塞控制

###### 重传

###### 安全

1. DDoS 拒绝服务攻击（SYN洪水攻击）

   攻击者发送大量的TCP SYN报文段，但是不完成第三次握手，导致服务器不断地为这些半开连接（但是未被使用）从而耗尽资源。应对方法Syn cookie

###### 扩展

- Seq numbner  等于上一条报文的Ack number 

- Ack number 等于上一条报文的Seq number + 1

- ISN 即初始化序号（Initial Sequence Number），是一个随机数不可预测，每次建立新的TCP连接发起的SYn报文携带的序号就是ISN

- ISN 的计算方法 

  ```java
  int ISN = M + F(localhost, localport, remotehost, remoteport);
  ```

  其中M是一个计时器，每隔4毫秒加1，F是一个Hash算法（根据源IP、源端口、目的IP、目的端口）生成一个随机数字，这个算法可能不准确，但是打开意思就是这个。

- Syn cookie 方法：服务器在接收到SYN报文以后，不会立即生成一个半连接，而是通过使用ISN的计算方法计算得出此报文的初始ISN，这样的ISN称为“cookie”，并将携带此序列号的SYNACK报文发送给客户端，如果客户端合法那么会接着给服务器发送ACK报文确认建立连接，此时服务器将会为此客户端分配资源。、

- TCP的状态序列

  服务端

  ![服务端TCP状态序列](https://img-blog.csdn.net/20180423135904399?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtZXI4NDExMTk1NTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  客户端

  ![客户端TCP状态序列](https://img-blog.csdn.net/20180423135815703?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtZXI4NDExMTk1NTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

##### 位运算&二进制

###### 基础运算

1. 与 & 

   1001 0010 & 1001 1101 = 1001 0000 

   规则：同为1 则为1

2. 或 | 

   1001 0010 | 1001 1101 = 1001 1111 

   规则：有一个或同为1 则为1

3. 异或  ^

   1001 0010 | 1001 1101 = 0000 1111 

   规则：相异则为1

4. 左移 << 、右移>>

   1001 0010 >> 2 = 0010 0100 空位由0填充

   1001 0010 << 2 = 0100 1000 空位由0填充

###### Color

表示颜色有(每一个字段对应2个比特，即表示一个完整的颜色需要8位二进制) aRGB （透明度（默认为FF）、红、绿、蓝）

```java
@ColorInt
int color = 0x331122;
int alpha = color>>6 & 0xFF; 	//获取透明度 FF
int red = color>>4 & 0xFF; 		//获取红色 33
int green = color>>2 & 0xFF;	//获取绿色 11
int blue = color & 0xFF;		//获取蓝色 22
```



###### 总结

通过灵活使用位运算可以在一个小小的int身上保存多个状态，甚至可以通过异或运算做一些更加神奇的事情。

#### java基础（单例synchronized、volatile）

##### synchronized

java关键字，可以用来修饰方法和代码块，其中修饰方法时锁定的是对象的this指针如果是静态方法则锁定此类的所有对象，代码块的话则看你传入的是什么了。

**作用**：一个线程访问一个对象中的synchronized步代码块时，其他试图访问该对象的线程将被阻塞，这是典型的悲观锁机制。

翻译成字节码时会在代码块头部和尾部分别加上monitorenter、monitorexit

```java
void synchronized function(){
    //锁定对象this
}

static void synchronized function2(){
    //锁定此类的所有对象
} 

void function3(){
    Object o = new Object();
    synchronized(o){
        //锁定传入的对象o
    }
}
```

**注意**：

1. 不能修饰构造方法
2. 不能修饰接口方法
3. 父类的方法使用了synchronized修饰则子类须显示添加synchronized才能同步，不加也可以不过不同步

##### volatile

java关键字，修饰的变量将具有可见性，却无法保证原子性，且屏蔽指令重排序。

- 可见性：多个线程访问同一个变量时，某个线程修改了变量，其他线程立即能看到修改的值
- 指令重排序：时编译器和处理器为了高效优化程序的手段，只能保证程序执行的结果时正确的，但是无法保证程序的操作顺序与代码顺序一致。在单线程中没有什么影响在多线程中就会出现问题。单例模式中添加volatile就是为了避免指令重排序。
- 原子性：**即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。** 

##### CAS 

CAS 全名  Compare and Swap 即比较和交换

它是一种乐观机制，java中的各种原子类都是用它来实现的。



#### Android 基础（四大组件、Handler、Looper、View）





